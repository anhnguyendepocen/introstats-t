---
title: 'chapter 3 Wrangling and Visualizing Data'
output:
  tufte::tufte_html:
    tufte_features: ['fonts','background']
    toc: true
  tufte::tufte_handout:
    citation_package: natbib
    latex_engine: xelatex
  tufte::tufte_book:
    citation_package: natbib
link-citations: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(collapse = FALSE)
library(tidyverse)
library(ggplot2)
library(knitr)
library(extraDistr)
library(gridExtra)
library(latex2exp)
library(moments)
library(bookdown)
library(rsconnect)
library(tufte)
```

```{r, include=FALSE}
cardiacdata <- read.csv('./data/normtemp.csv') 
```

\newcommand{\E}{\text{E}}
\newcommand{\Var}{\text{Var}}
\newcommand{\SD}{\text{SD}}
\newcommand{\SE}{\text{SE}}
\newcommand{\Cov}{\text{Cov}}
\newcommand{\Cor}{\text{Cor}}
\renewcommand{\P}{\text{P}}
\newcommand{\pd}[2]{\frac{\partial #1}{\partial #2}}
\newcommand{\sumin}{\sum_i^n}
\newcommand{\Bias}{\text{Bias}}

---

# Wrangling Data

Wrangling data refers to cleaning/manipulating/reorganizing raw data to make it more useful for analysis. The `dplyr` package has a host of functions specifically for this purpose. This section will introduce you to a few. 

\ 

## Indexing

Elements in a vector, matrix, or data frame can be extracted using square brackets (numerical indexing). Indexing in R starts at 1 (in some other languages such as Python indexing starts at 0).   

Below are some examples of indexing from the cardiac dataset:

```{r}
# extract element in 1st row and 3th column
cardiacdata[1,3]
```

```{r}
# extract rows 5-7 from columns 1-3
cardiacdata[5:7,1:3]
```

\ 

## Extracting

The extract operator, `$`, can extract a named element from a list. Since a data frame is a list, the `$` operator can be used to extract columns from a data frame:

```{r}
# extract column 'bodytemp' and assign to new object 'temperatures'
temperatures <- cardiacdata$bodytemp
```

\ 

## Selecting columns

Use `select()`:  

```{r}
# select columns 'gender' and 'heartrate' and assign to new object 'heartrates'
heartrates <- select(cardiacdata, gender, heartrate)
```

The first argument in the `select()` function is the data frame you are selecting from, and subsequent arguments are variables you want to select.  

\ 

## Renaming columns

Use `rename()`:

`r margin_note("Note since these operations are assigned to 'cardiacdata', you should find they overwrite the contents of the original data frame. If you want to preserve the original data you should assign your changes to a new data object.")`

```{r}
## append variable names with their respective units
# rename 'bodytemp' to 'bodytemp_degF'
cardiacdata <- rename(cardiacdata, bodytemp_degF = bodytemp)

# rename 'heartrate' to 'heartrate_bpm'
cardiacdata <- rename(cardiacdata, heartrate_bpm = heartrate)
```

Below is a preview of the modified cardiac dataset--now with different column names: 

```{r}
head(cardiacdata)
```

\ 

## Adding/changing columns

Use `mutate()`:

`r margin_note("Where $^oC = ( ^oF - 32) \\cdot \\frac{5}{9}$")`

```{r}
# add new column with body temperature in degrees celsius
cardiacdata <- mutate(cardiacdata, bodytemp_degC = (bodytemp_degF - 32)*(5/9))
```

`r margin_note("Note the double equals sign, $==$. In R (and many other languages) a double equals sign represents equality (LHS equals RHS) while a single equals sign represents variable assignment.")`  

```{r}
# change values in gender column to read "Female" and "Male" instead of 1 and 2
cardiacdata <- mutate(cardiacdata, gender = ifelse(gender == 1, 'Female', 
                                            ifelse(gender == 2, 'Male', NA)))
```

`r margin_note("Read about the $\\texttt{ifelse()}$ function <a href='https://www.ncbi.nlm.nih.gov/pubmed/1302471'>here.</a>")`

See these changes below:

```{r}
head(cardiacdata)
```


\ 

## Filtering data

Use `filter()`:

```{r}
# filter for data from female subjects only
cardiacdata_female <- filter(cardiacdata, gender == 'Female')
```

\ 

## Piping

The pipe operator, `%>%`, is useful for performing functions simultaneously.  

Theoretically: say you have an object, `x`, and you want to perform three functions on it: `f()`, `g()`, and `h()`. You could do:

```
f(x)
g(x)
h(x)
```

Running these three lines of code sequentially would the run `x` through `f()`, then run the result through `g()`, then run that result through `h()`. A cleaner way to do this is by running it all in one 'pipe':

```
x %>% f() %>% g() %>% h()
```

In short, the pipe operator forwards ('pipes') the values on its left hand side into the expression(s) on its right hand side.  

E.g. say you want to take the cardiac data, filter for females, drop the column `gender`, and add a new column calculating body temperature in Kelvin:  

`r margin_note("Brilliant.")`  

```{r}
cardiacdata <- cardiacdata %>%
  filter(gender == 'Female') %>%
  select(-gender) %>%
  mutate(bodytemp_Kelvin = bodytemp_degC + 273)
```

\ 

## Aggregating data

Aggregating data is useful if you want to find summary statistics across particular categories in the data. When aggregating data you must specify your grouping variable (which should be categorical), and you must perform some function (usually a sum or mean) on the non-grouping variables (which should be numeric).    

There are many ways to aggregate data. One way is using `group_by()` to specify the grouping variable(s) and `summarize()` to specify the function you want to perform on the non-grouping variable(s).^[Another way is using the `aggregate()` function.]  

E.g. to compare averages across gender, use gender as the grouping variable and calculate means for the other variables: 

`r margin_note("Note the variable names are also modified to reflect the aggregated statistics.")`

```{r, include=FALSE}
cardiacdata <- read.csv('./data/normtemp.csv') %>%
  rename(bodytemp_degF = bodytemp, heartrate_bpm = heartrate) %>%
  mutate(bodytemp_degC = (bodytemp_degF - 32)*(5/9), 
         gender = ifelse(gender == 1, 'Female', 
                         ifelse(gender == 2, 'Male', NA)))  
```

```{r, warning=FALSE}
cardiacdata_byGender <- cardiacdata %>%
  group_by(gender) %>%                                  # group by 'gender'
  summarize(avg_bodytemp_degF = mean(bodytemp_degF),    # aggregate using means
            avg_bodytemp_degC = mean(bodytemp_degC), 
            avg_heartrate_bpm = mean(heartrate_bpm))  
```

The aggregated data frame, `cardiacdata_byGender`, should look as follows: 

```{r, echo=FALSE}
kable(cardiacdata_byGender, caption = 'The aggregated cardiac data.')
```


\ 

## Dealing with missing data

If your data contains missing values (NA values), some functions may not run as expected:

```{r}
some_numbers <- c(4,5,6,7,NA,8)

mean(some_numbers)
```

If you want the function to skip all missing values, you should specify the argument `na.rm = TRUE` (by default it is set to `FALSE` for most functions):

```{r}
mean(some_numbers, na.rm = TRUE)
```



\ 

---

# Visualizing Data

`ggplot2` is the main plotting library in R. Note although the package name is `ggplot2`, the function call is simply `ggplot()`. To make a plot you need to provide `ggplot()` with two arguments, `data` and `mapping`:

- `data` -- the data frame you want to plot
- `mapping` -- an aesthetic mapping for variable(s) go on which axes  

The following examples will demonstrate how to use `ggplot()`. Here is a ggplot <a href="base64 data" download="./downloads/ggplot2-cheatsheet.pdf">cheatsheet</a>.   

\ 

## Histograms

Histograms are a good way to visualize the distribution of data, since they display the frequency (or relative frequency) of observations within specified intervals or 'bins'.  

To plot a histogram you must specify `+ geom_histogram()` after the main function call. Histograms only require one variable (for the $x$-axis; the $y$-axis is simply frequency).  

The following code plots a histogram of the variable body temperature:

`r margin_note("Note the argument $\\texttt{bins=20}$ in $\\texttt{geom_histogram()}$. This specifies your histogram will have 20 bins. Alternatively you could use the argument $\\texttt{binwidth=XXX}$ to specify that each bin should have a certain width.")`

```{r}
ggplot(data = cardiacdata, mapping = aes(x = bodytemp_degC)) + 
  geom_histogram(bins = 20)
```

If you want relative frequency on the $y$-axis (a density plot) you can specify the aesthetic mapping `y = ..density..` in `geom_histogram()`:

```{r}
ggplot(data = cardiacdata, mapping = aes(x = bodytemp_degC)) + 
  geom_histogram(bins = 20, aes(y = ..density..))
```

You can make the plot prettier by adding axis labels and changing the colors and theme:

```{r}
ggplot(data = cardiacdata, mapping = aes(x = bodytemp_degC)) + 
  geom_histogram(bins = 20, aes(y = ..density..), fill = 'lightblue') +
  xlab('body temperature (celsius)') +
  ggtitle('distribution of body temperatures') +
  theme_light()
```

\ 

## Scatterplots

Scatterplots require two variables--one for $x$ and one for $y$. To make a scatterplot you must specify `+ geom_point()` after the main function call. 

Below is a scatterplot of heart rate on body temperature:

```{r}
ggplot(data = cardiacdata, mapping = aes(x = heartrate_bpm, y = bodytemp_degC)) + 
  geom_point() +
  theme_light()
```

To distinguish between females and males, you can add another argument to the aesthetic mapping, `color = gender`. This will use different colors for data points corresponding to each gender:^[For obvious reasons, the color mapping requires a categorical variable. A different color will be used for each category.]

```{r}
ggplot(data = cardiacdata, mapping = aes(x = heartrate_bpm, y = bodytemp_degC, color = gender)) + 
  geom_point() +
  theme_light()
```


\ 

## Box & Whisker Plots 

Box and whisker plots require two variables; one should be categorical and the other should be numeric. To make a box and whisker plot you must specify `+ geom_boxplot()` after the main function call.  

Below is a box and whisker plot of body temperature (continuous) on gender (categorical): 

```{r}
ggplot(data = cardiacdata, mapping = aes(x = gender, y = bodytemp_degC)) +
  geom_boxplot() +
  xlab('gender') +
  ylab('body temperature (celsius)') +
  theme_light()
```

You can see R marks outliers (values substantially outside the interquartile range) as separate points.  

\ 

## Tables

One way (among many) to create elegant tables in your R Markdown output file is using `kable()` from the `knitr` package.^[Note `kable()` is optimized for pdf output files--you may have issues if your output format is html.] Below are some examples:

\ 

```{r}
kable(cardiacdata[1:6, ], caption = 'Rows 1-6 of the cardiac dataset.') 
```

\ 

```{r}
kable(cardiacdata_byGender, caption = 'Cardiac dataset aggregated by gender.')
```




\ 

---

\ 


